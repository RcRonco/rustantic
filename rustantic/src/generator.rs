use std::collections::HashSet;
use std::env;
use std::fs;
use std::path::PathBuf;

use crate::collector::MetadataCollector;
use crate::models::ConstructorMetadata;
use crate::models::PydanticMetadata;
use convert_case::{Case, Casing};
use syn::GenericArgument;
use syn::PathArguments;
use syn::Type;
use syn::TypePath;

#[derive(Default)]
struct FieldGenerationResult {
    pub code: String,
    pub additional_imports: HashSet<String>,
}

impl FieldGenerationResult {
    fn add_any_import(&mut self) {
        self.additional_imports
            .insert("from typing import Any".to_string());
    }

    fn add_optional_import(&mut self) {
        self.additional_imports
            .insert("from typing import Optional".to_string());
    }

    fn add_pydantic_field_import(&mut self) {
        self.additional_imports
            .insert("from pydantic import Field".to_string());
    }
}

pub struct PydanticCodeGenerator {
    header_comment: String,
    package_name: String,
    base_path: String,
    models_package_name: String,
    collector: MetadataCollector,
}

impl PydanticCodeGenerator {
    pub fn generate(
        package_name: &str,
        base_path: &str,
        lib_path: &str,
        models_package_name: &str,
    ) {
        let version = env::var("CARGO_PKG_VERSION").unwrap();
        let header_comment = format!("# Generated by rustantic version: {}", version).to_string();
        println!(
            "cargo::warning=Rustantic generator stated, packageName='{}', basePath'{}', libPath='{}'",
            &package_name, &base_path, &lib_path
        );

        let mut generator = Self {
            header_comment,
            package_name: package_name.to_owned(),
            base_path: base_path.to_string(),
            collector: MetadataCollector::new(lib_path),
            models_package_name: models_package_name.to_string(),
        };

        generator.collector.collect();

        println!(
            "cargo:warning=Rustantic collected '{}' items",
            generator.collector.structs().len()
        );
        generator.generate_init_file();
        generator
            .collector
            .structs()
            .iter()
            .for_each(|(ident, meta)| {
                generator.generate_pydantic_file(ident, meta);
            });
    }

    fn generate_init_file(&self) {
        let mut path = PathBuf::from(&self.base_path);
        path.push("__init__.py");
        fs::create_dir_all(path.parent().unwrap()).unwrap();
        fs::write(&path, "").unwrap();
    }

    fn generate_pydantic_file(&self, identifier: &str, meta: &PydanticMetadata) {
        println!(
            "cargo:warning=Start Rustantic generator for item: {}",
            identifier
        );
        let generated_code = self.generate_pydantic_code(meta);
        let mut path = PathBuf::from(&self.base_path);
        path.push(self.create_path(identifier));

        fs::create_dir_all(path.parent().unwrap()).unwrap();
        fs::write(&path, generated_code).unwrap();
    }

    fn create_path(&self, identifier: &str) -> String {
        format!("{}.py", identifier.to_string().to_case(Case::Snake))
    }

    fn generate_pydantic_code(&self, meta: &PydanticMetadata) -> String {
        let mut import_code = format!(
            "from pydantic import BaseModel\nimport {}\n",
            self.package_name
        );
        let mut code = format!("class {}(BaseModel):\n", &meta.ident);
        let mut additional_imports: HashSet<String> = HashSet::new();
        match meta.constructor {
            Some(ref ctor) => {
                for (arg_name, arg_ty) in ctor.args.iter() {
                    let field_result = self.generate_pydantic_named_field(&arg_name, arg_ty);
                    additional_imports.extend(field_result.additional_imports);
                    code.push_str(&format!("    {}\n", field_result.code));
                }
                code.push_str("\n");
                code.push_str(&self.generate_to_pyo3_fn("    ", &meta.ident, ctor));
            }
            None => {
                code.push_str(
                    &self.generate_invalid_model_body(&meta.ident, "No pyo3 constructor"),
                );
            }
        };

        additional_imports
            .iter()
            .for_each(|s| import_code.push_str(&format!("{}\n", s)));

        format!("{}\n{}\n{}", self.header_comment, import_code, code)
    }

    fn generate_invalid_model_body(&self, ident: &str, error: &str) -> String {
        println!(
            "cargo::warning=Rustantic '{}' generation failed, error: {}",
            ident, error
        );
        let mut code = format!("    # Invalid model definition: {}\n", error);
        code.push_str("    pass\n");
        code
    }

    fn generate_pydantic_named_field(&self, name: &str, ty: &Type) -> FieldGenerationResult {
        let mut result = FieldGenerationResult::default();
        let ty_def = self.rust_type_to_pydantic(ty);
        result.code = format!("{}: {}", name, ty_def.code);
        result.additional_imports = ty_def.additional_imports.clone();
        result
    }

    fn generate_to_pyo3_fn(
        &self,
        indent: &str,
        struct_name: &str,
        constructor: &ConstructorMetadata,
    ) -> String {
        let mut code = format!("{0}def to_rs(self):\n", indent);
        code.push_str(&format!(
            "{0}{0}return {1}.{2}(\n",
            indent, self.package_name, struct_name
        ));
        for (arg_name, arg_ty) in constructor.args.iter() {
            if let Some(ident_str) = self.get_type_ident(arg_ty) {
                if self.collector.structs().contains_key(&ident_str) {
                    code.push_str(&format!(
                        "{0}{0}{0}{1}=self.{1}.to_rs(),\n",
                        indent, arg_name
                    ));
                } else {
                    code.push_str(&format!("{0}{0}{0}{1}=self.{1},\n", indent, arg_name));
                }
            } else {
                code.push_str(&format!("{0}{0}{0}{1}=self.{1},\n", indent, arg_name));
            }
        }
        code.push_str(&format!("{0}{0})", indent));

        code
    }

    fn get_type_ident(&self, ty: &Type) -> Option<String> {
        if let Type::Path(path_ty) = ty {
            if path_ty.qself.is_none() {
                let segment = path_ty.path.segments.last().unwrap();
                Some(segment.ident.to_string())
            } else {
                None
            }
        } else {
            None
        }
    }

    fn rust_type_to_pydantic(&self, ty: &Type) -> FieldGenerationResult {
        let mut result = FieldGenerationResult::default();
        match ty {
            // Handle common types
            Type::Path(type_path) => {
                result = self.path_to_pydantic(type_path);
            }
            // Handle references like `&str` if you want
            Type::Reference(ref_type) => {
                // If it's `&str`, treat like `String`
                result.code = if let Type::Path(inner_path) = &*ref_type.elem {
                    let last_seg = inner_path.path.segments.last().unwrap().ident.to_string();
                    if last_seg == "str" {
                        "str".to_string()
                    } else {
                        result.add_any_import();
                        format!("Any  # Reference to {last_seg}")
                    }
                } else {
                    result.add_any_import();
                    format!("Any # Unknown ref type")
                };
            }

            // Catch-all for function pointers, never types, tuples, etc.
            _ => {
                result.add_any_import();
                result.code = format!("Any # Unknown type kind");
            }
        };

        result
    }

    fn path_to_pydantic(&self, type_path: &TypePath) -> FieldGenerationResult {
        let mut result = FieldGenerationResult::default();
        if type_path.qself.is_none() {
            // Get the last segment of the path, e.g. "Vec" for "std::vec::Vec"
            let segment = type_path.path.segments.last().unwrap();
            let ident_str = segment.ident.to_string();

            result.code = match ident_str.as_str() {
                "i8" | "i16" | "i32" | "i64" => "int".to_string(),
                "u8" | "u16" | "u32" | "u64" | "isize" | "usize" => {
                    result.add_pydantic_field_import();
                    "int = Field(..., ge=0)".to_string()
                }
                "f32" | "f64" => "float".to_string(),
                "bool" => "bool".to_string(),
                "String" => "str".to_string(),
                "Option" => {
                    result.add_optional_import();
                    if let PathArguments::AngleBracketed(angle_args) = &segment.arguments {
                        if let Some(GenericArgument::Type(inner_ty)) = angle_args.args.first() {
                            let inner_py = self.rust_type_to_pydantic(inner_ty);
                            format!("Optional[{}]", inner_py.code)
                        } else {
                            result.add_any_import();
                            "Optional[Any]".to_string()
                        }
                    } else {
                        result.add_any_import();
                        "Optional[Any]".to_string()
                    }
                }
                "Vec" => {
                    if let PathArguments::AngleBracketed(angle_args) = &segment.arguments {
                        if let Some(GenericArgument::Type(inner_ty)) = angle_args.args.first() {
                            let inner_py = self.rust_type_to_pydantic(inner_ty);
                            format!("list[{}]", inner_py.code)
                        } else {
                            result.add_any_import();
                            "list[Any]".to_string()
                        }
                    } else {
                        result.add_any_import();
                        "list[Any]".to_string()
                    }
                }
                // Custom or unknown type
                _ => {
                    // Custom pydantic ref
                    if let Some(meta) = self.collector.structs().get(&ident_str) {
                        result.additional_imports.insert(format!(
                            "from {0}.{1} import {2} as Pydantic{2}",
                            &self.models_package_name,
                            &meta.ident.to_case(Case::Snake),
                            &meta.ident
                        ));
                        format!("Pydantic{}", ident_str.as_str())
                    }
                    // Unknown type
                    else {
                        result.add_any_import();
                        format!("Any # Unknown type {}", ident_str.as_str())
                    }
                }
            };
        } else {
            // Qualified (e.g. <T as Trait>::Type). We'll just fallback:
            result.add_any_import();
            "Any".to_string();
        }

        result
    }
}
